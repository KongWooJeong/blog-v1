---
title: Codility Lesson 7 - Fish
date: 2023-07-17 14:00:21
category: Algorithm
draft: false
---

## 문제 설명

N개의 정수로 구성된 비어 있지 않은 두 개의 배열 A와 B가 주어집니다. 배열 A와 B는 강에 있는 탐욕스러운 물고기 N마리를 나타내며, 강의 흐름을 따라 하류로 정렬되어 있습니다.  

물고기의 번호는 0부터 N-1까지입니다. P와 Q가 두 물고기이고 P < Q인 경우, 물고기 P는 처음에 물고기 Q의 상류에 있습니다. 처음에는 각 물고기의 위치가 고유합니다.  

물고기 번호 P는 A[P] 및 B[P]로 표시됩니다. 배열 A는 물고기의 크기를 포함합니다. 모든 요소는 고유합니다. 배열 B에는 물고기의 방향이 포함됩니다. 여기에는 0 및/또는 1만 포함됩니다:

- 0은 상류로 흐르는 물고기를 나타냅니다,

- 1은 하류로 흐르는 물고기를 나타냅니다.  

두 물고기가 서로 반대 방향으로 이동하고 그 사이에 다른 (살아있는) 물고기가 없으면 결국 서로 만나게 됩니다. 그러면 한 마리만 살아남을 수 있는데, 큰 물고기가 작은 물고기를 잡아먹습니다. 더 정확하게는 두 물고기 P와 Q가 P < Q, B[P] = 1, B[Q] = 0이고 그 사이에 살아있는 물고기가 없을 때 서로 만난다고 말합니다.   

그들이 만난 후:

- A[P] > A[Q]라면 P는 Q를 먹고, P는 여전히 하류로 흐르고 있을 것입니다,
- A[Q]> A[P]라면 Q가 P를 잡아먹고, Q는 여전히 상류로 흐르게 됩니다.

모든 물고기가 같은 속도로 흐른다고 가정합니다. 즉, 같은 방향으로 이동하는 물고기는 절대 만나지 않습니다. 목표는 살아남을 물고기 수를 계산하는 것입니다.

예를 들어 배열 A와 B가 다음과 같다고 가정해 보겠습니다:

```
  A[0] = 4 B[0] = 0
  A[1] = 3 B[1] = 1
  A[2] = 2 B[2] = 0
  A[3] = 1 B[3] = 0
  A[4] = 5 B[4] = 0
```

처음에는 모든 물고기가 살아 있고 1번 물고기를 제외한 모든 물고기가 상류로 이동하고 있습니다. 1번 물고기는 2번 물고기를 만나서 먹은 다음, 3번 물고기를 만나서 역시 먹습니다. 마지막으로 4번 물고기를 만나서 잡아먹힙니다. 나머지 두 물고기인 0번과 4번은 서로 만나지 않으므로 살아남습니다.

함수를 작성합니다:

```javascript
function solution(A, B);
```

비어 있지 않은 두 개의 배열 A와 B가 주어졌을 때, N개의 정수로 구성된 물고기 중 살아남을 물고기 수를 반환하는 함수입니다.

예를 들어, 위에 표시된 배열이 주어지면 위에서 설명한 대로 함수는 2를 반환해야 합니다.

다음 가정에 대한 효율적인 알고리즘을 작성하세요:

- N은 [1..100,000] 범위 내의 정수입니다;
- 배열 A의 각 요소는 [0..1,000,000,000] 범위 내의 정수입니다;
- 배열 B의 각 요소는 다음 값 중 하나를 가질 수 있는 정수입니다: 0, 1;
- A의 요소는 모두 고유합니다.

## 문제 접근

*스택 구조를 활용하여 반복문을 순회하면서 살아남은 물고기들을 stack 에 담는다.*

1. 처음 스택에 가장 첫번째 물고기를 담는다.
2. 반복문을 순회하면 아래 조건 거친디:
3. 스택에 물고기를 담는다.
   - 현재 물고기 (B[index]) 가 하류(1) 가는 경우 그리고 스택에 있는 마지막 물고기(stack[stack.length - 1])가 상류로 흐를경우 
   - 즉, 서로 만나지 않을경우
4. 스택에 물고기를 꺼낸다.
   - 잡아먹히는 경우 (A[index] > B[index])
5. 마지막에 스택(배열)의 크기를 반환한다.

```javascript
function solution(A, B) {
    const stack = [0];
    let index = 1;

    while (index < A.length) {
        const lastFish = stack[stack.length - 1];

        if (B[index] === 0 && B[lastFish] === 1) {
            if (A[index] > A[lastFish]) {
                stack.pop();
            } else {
                index++;
            }
        } else {
            stack.push(index);
            index++;
        }
    }

    return stack.length;
}
```
